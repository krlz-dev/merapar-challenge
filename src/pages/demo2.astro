---
import fs from 'fs';
import path from 'path';

let dynamicString = "default dynamic string";

try {
  const dataPath = path.join(process.cwd(), 'src/data/text.json');
  const data = JSON.parse(fs.readFileSync(dataPath, 'utf-8'));
  dynamicString = data.dynamicString || dynamicString;
} catch (error) {
  console.error('Error reading dynamic text:', error);
}
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>Dynamic Text - Simple Polling Demo</title>
		<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
		<style>
			#dynamicText {
				font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
				font-weight: 100;
				color: #666666;
				font-size: 2.5rem;
				letter-spacing: -0.02em;
			}
			.polling-indicator {
				font-size: 0.9rem;
				color: #6c757d;
			}
			.badge {
				font-size: 0.75rem;
			}
		</style>
	</head>
	<body>
	 
		<div class="container mt-5">
			<div class="row justify-content-center">
				<div class="col-md-8">
					<div class="text-center">
						<h1 id="dynamicText">The saved string is {dynamicString}</h1>
						<div class="mt-3">
							<span class="badge bg-info" id="pollingStatus">Polling every 3 seconds</span>
							<div class="polling-indicator mt-2">
								<small>Last updated: <span id="lastUpdated">Page load</span></small>
							</div>
						</div>
						<div class="mt-4">
							<a href="/" class="btn btn-outline-secondary me-2">← Back to SSE Demo</a>
							<a href="/admin" class="btn btn-primary">Admin Panel</a>
						</div>
					</div>
				</div>
			</div>
			<div class="row justify-content-center mt-5">
				<div class="col-md-8">
					<div class="card">
						<div class="card-header">
							<h5 class="mb-0">About This Demo</h5>
						</div>
						<div class="card-body">
							<p class="card-text">
								This is a <strong>simple polling approach</strong> that fetches data every 3 seconds using regular HTTP requests. 
								Unlike the SSE demo, this approach:
							</p>
							<ul class="list-unstyled">
								<li>✅ <strong>Simple to implement</strong> - just a fetch() in setInterval()</li>
								<li>✅ <strong>No memory leaks</strong> - each request is independent</li>
								<li>✅ <strong>Works everywhere</strong> - no special browser support needed</li>
								<li>⚠️ <strong>Less efficient</strong> - makes requests even when no changes occur</li>
								<li>⚠️ <strong>Delayed updates</strong> - up to 3 second delay for changes</li>
								<li>⚠️ <strong>More server load</strong> - constant requests from all clients</li>
							</ul>
						</div>
					</div>
				</div>
			</div>
		</div>
		
		<script>
			const dynamicTextElement = document.getElementById('dynamicText');
			const pollingStatus = document.getElementById('pollingStatus');
			const lastUpdatedElement = document.getElementById('lastUpdated');
			
			let pollCount = 0;
			
			async function fetchLatestText() {
				try {
					pollingStatus.textContent = 'Fetching...';
					pollingStatus.className = 'badge bg-warning';
					
					const response = await fetch('/api/text');
					if (response.ok) {
						const data = await response.json();
						if (data.dynamicString) {
							dynamicTextElement.textContent = `The saved string is ${data.dynamicString}`;
						}
						
						pollingStatus.textContent = 'Polling every 3 seconds';
						pollingStatus.className = 'badge bg-info';
						
						const now = new Date().toLocaleTimeString();
						lastUpdatedElement.textContent = now;
						pollCount++;
						
						console.log(`Poll #${pollCount}: Updated text at ${now}`);
					} else {
						throw new Error(`HTTP ${response.status}`);
					}
				} catch (error) {
					console.error('Error fetching text:', error);
					pollingStatus.textContent = 'Error - Retrying...';
					pollingStatus.className = 'badge bg-danger';
				}
			}
			
			// Start polling every 3 seconds
			const pollingInterval = setInterval(fetchLatestText, 3000);
			
			// Clean up polling when page unloads
			window.addEventListener('beforeunload', function() {
				clearInterval(pollingInterval);
			});
			
			// Set initial last updated time
			lastUpdatedElement.textContent = new Date().toLocaleTimeString();
		</script>
	</body>
</html>